pragma solidity ^0.4.24;


contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  constructor() public {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to relinquish control of the contract.
   * @notice Renouncing to ownership will leave the contract without an owner.
   * It will not be possible to call the functions with the `onlyOwner`
   * modifier anymore.
   */
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  /**
   * @dev Transfers control of the contract to a newOwner.
   * @param _newOwner The address to transfer ownership to.
   */
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}

interface ERC165 {

  /**
   * @notice Query if a contract implements an interface
   * @param _interfaceId The interface identifier, as specified in ERC-165
   * @dev Interface identification is specified in ERC-165. This function
   * uses less than 30,000 gas.
   */
  function supportsInterface(bytes4 _interfaceId)
    external
    view
    returns (bool);
}

contract SupportsInterfaceWithLookup is ERC165 {

  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;
  /**
   * 0x01ffc9a7 ===
   *   bytes4(keccak256('supportsInterface(bytes4)'))
   */

  /**
   * @dev a mapping of interface id to whether or not it's supported
   */
  mapping(bytes4 => bool) internal supportedInterfaces;

  /**
   * @dev A contract implementing SupportsInterfaceWithLookup
   * implement ERC165 itself
   */
  constructor()
    public
  {
    _registerInterface(InterfaceId_ERC165);
  }

  /**
   * @dev implement supportsInterface(bytes4) using a lookup table
   */
  function supportsInterface(bytes4 _interfaceId)
    external
    view
    returns (bool)
  {
    return supportedInterfaces[_interfaceId];
  }

  /**
   * @dev private method for registering an interface
   */
  function _registerInterface(bytes4 _interfaceId)
    internal
  {
    require(_interfaceId != 0xffffffff);
    supportedInterfaces[_interfaceId] = true;
  }
}

interface IERC1261 /* is ERC173, ERC165 */ {
    /// @dev This emits when a token is assigned to a member.
    event Assigned(address indexed to);

    /// @dev This emits when a membership is revoked.
    event Revoked(address indexed to);

    /// @dev This emits when data of a member is modified. 
    ///  Doesn't emit when a new membership is created and data is assigned.
    event ModifiedData(address indexed to);
    
    /// @notice Queries whether a member is a current member of the organization.
    /// @dev MVT's assigned to the zero address are considered invalid, and this
    ///  function throws for queries about the zero address.
    /// @param _to An address for whom to query the membership.
    /// @return Whether the member owns the token.
    function isCurrentMember(address _to) external view returns (bool);

    /// @notice Returns the list of all past and present members.
    /// @dev Use this function along with isCurrentMember to find wasMemberOf() in Js.
    ///  It can be calculated as present in getAllMembers() and !isCurrentMember().
    /// @return List of addresses who have owned the token and currently own the token.
    function getAllMembers() external view returns (address[]);

    /// @notice Returns the list of all attribute names.
    /// @dev Returns the names of attributes as a bytes32 array. 
    ///  AttributeNames are stored in a bytes32 Array.
    ///  Possible values for each attributeName are stored in a mapping(attributeName => attributeValues).
    ///  AttributeName is bytes32 and attributeValues is bytes32[].
    ///  Attributes of a particular user are stored in bytes32[].
    ///  Which has a single attributeValue for each attributeName in an array.
    ///  Use web3.toAscii(data[0]).replace(/\u0000/g, "") to convert to string in JS.
    /// @return The names of attributes.
    function getAttributeNames() external view returns (bytes32[]);

    /// @notice Returns the attributes of `_to` address.
    /// @dev Throws if `_to` is the zero address.
    ///  Use web3.toAscii(data[0]).replace(/\u0000/g, "") to convert to string in JS.
    /// @param _to The address whose current attributes are to be returned.
    /// @return The attributes associated with `_to` address.
    function getAttributes(address _to) external view returns (bytes32[]);

    /// @notice Returns the `attribute` stored against `_to` address.
    /// @dev Finds the index of the `attribute`.
    ///  Throws if the attribute is not present in the predefined attributes.
    ///  Returns the attributeValue for the specified `attribute`.
    /// @param _to The address whose attribute is requested.
    /// @param attribute The attribute name which is required.
    /// @return The attribute value at the specified name.
    function getAttributeByName(address _to, bytes32 attribute) external view returns (bytes32);

    /// @notice Adds a new attribute (key, value) pair to the set of pre-existing attributes.
    /// @dev Adds a new attribute at the end of the array of attributes and maps it to `values`.
    ///  Contract can set a max number of attributes and throw if limit is reached.
    /// @param _name Name of the attribute which is to be added.
    /// @param values List of values of the specified attribute.
    function addAttributeSet(bytes32 _name, bytes32[] values) external;
    
    /// @notice Modifies the attribute value of a specific attribute for a given `_to` address.
    /// @dev Use appropriate checks for whether a user/admin can modify the data.
    ///  Best practice is to use onlyOwner modifier from ERC173.
    /// @param _to The address whose attribute is being modified.
    /// @param _attributeName The attribute name which is being modified.
    /// @param _modifiedValueIndex The index of the new value which is being assigned to the user attribute.
    function modifyAttributeByName(address _to, bytes32 _attributeName, uint _modifiedValueIndex) external;

    /// @notice Requests membership from any address.
    /// @dev Throws if the `msg.sender` already has the token.
    ///  The individual `msg.sender` can request for a membership and if some exisiting criteria are satisfied.
    ///  The individual `msg.sender` receives the token.
    ///  When the token is assigned, this function emits the Assigned event.
    /// @param data the attribute data associated with the member.
    ///  This is an array which contains indexes of attributes.
    function requestMembership(uint[] data) external payable;

    /// @notice User can forfeit his membership.
    /// @dev Throws if the `msg.sender` already doesn't have the token.
    ///  The individual `msg.sender` can revoke his/her membership.
    ///  When the token is revoked, this function emits the Revoked event.
    function forfeitMembership() external payable;

    /// @notice Assigns membership of an MVT from owner address to another address.
    /// @dev Throws if the member already has the token.
    ///  Throws if `_to` is the zero address.
    ///  Throws if the `msg.sender` is not an owner.
    ///  The entity assigns the membership to each individual.
    ///  When the token is assigned, this function emits the Assigned event.
    /// @param _to The address to which the token is assigned.
    /// @param data The attribute data associated with the member.
    ///  This is an array which contains indexes of attributes.
    function assignTo(address _to, uint[] data) external;

    /// @notice Only Owner can revoke the membership.
    /// @dev This removes the membership of the user.
    ///  Throws if the `_from` is not an owner of the token.
    ///  Throws if the `msg.sender` is not an owner.
    ///  Throws if `_from` is the zero address.
    ///  When transaction is complete, this function emits the Revoked event.
    /// @param _from The current owner of the MVT.
    function revokeFrom(address _from) external;
}

contract ElectusProtocol is IERC1261, Ownable, SupportsInterfaceWithLookup {
    struct MemberData{
        bool hasToken;
        bytes32[] data;
    }

    mapping(bytes32 => bytes32[]) public attributeValueCollection;

    bytes32[] public attributeNames;

    mapping(address => MemberData) public currentHolders;

    address[] public allHolders;

    event Assigned(address indexed to);
    event Revoked(address indexed to);
    event ModifiedAttributes(address indexed to);

    constructor () public {
        supportedInterfaces[0x912f7bb2] = true; //IERC1261
        supportedInterfaces[0x83adfb2d] = true; //Ownable
        attributeNames.push("hair");
        attributeNames.push("skin");
        attributeNames.push("height");
        attributeValueCollection["hair"].push("black");
        attributeValueCollection["hair"].push("white");
        attributeValueCollection["skin"].push("black");
        attributeValueCollection["skin"].push("white");
        attributeValueCollection["height"].push("1.5");
    }

    modifier isCurrentHolder {
        require(isCurrentMember(msg.sender), "Not a current member");
        _;
    }

    modifier isNotACurrentHolder {
        require(!isCurrentMember(msg.sender), "Already a member");
        _;
    }

    function isCurrentMember(address _to) public view returns (bool){
        require(_to != address(0), "Zero address can't be a member");
        return currentHolders[_to].hasToken;
    }

    function getAllMembers() external view returns (address[]) {
        return allHolders;
    }

    function getAttributeNames() external view returns (bytes32[]) {
        return attributeNames;
    }

    function getAttributes(address _to) external view returns (bytes32[]) {
        require(_to != address(0));
        return currentHolders[_to].data;
    }

    function getAttributeByName(address _to, bytes32 attribute) external view returns (bytes32) {
        uint index = getIndexOfAttribute(attribute);
        return currentHolders[_to].data[index];
    }

    function addAttributeSet(bytes32 _name, bytes32[] values) external {
        attributeNames.push(_name);
        attributeValueCollection[_name] = values;
    }

    function modifyAttributeByName(address _to, bytes32 _attributeName, uint _modifiedValueIndex) external onlyOwner {
        uint attributeIndex = getIndexOfAttribute(_attributeName);
        currentHolders[_to].data[attributeIndex] = attributeValueCollection[attributeNames[attributeIndex]][_modifiedValueIndex];
        emit ModifiedAttributes(_to);
    }

    function requestMembership(uint[] attributeIndexes) external isNotACurrentHolder payable {
        //Do some checks before assigning membership
        _assign(msg.sender, attributeIndexes);
    }

    function forfeitMembership() external isCurrentHolder payable {
        _revoke(msg.sender);
    }

    function assignTo(address _to, uint[] attributeIndexes) external onlyOwner {
        _assign(_to, attributeIndexes);
    }

    function revokeFrom(address _from) external onlyOwner {
        _revoke(_from);
    }

    function _assign(address _to, uint[] attributeIndexes) private {
        require(_to != address(0), "Can't assign to zero address");        
        MemberData memory member;
        member.hasToken = true;
        currentHolders[_to] = member;
        for(uint index = 0; index < attributeIndexes.length; index++) {
            currentHolders[_to].data.push(attributeValueCollection[attributeNames[index]][attributeIndexes[index]]);
        }
        allHolders.push(_to);
        emit Assigned(_to);
    }

    function _revoke(address _from) private {
        require(_from != address(0), "Can't revoke from zero address");
        MemberData storage member = currentHolders[_from];
        member.hasToken = false;
        emit Revoked(_from);
    }
    
    function getIndexOfAttribute(bytes32 attribute) internal view returns (uint) {
        uint index = 0;
        bool isAttributeFound = false;
        for(uint i = 0; i < attributeNames.length; i++) {
            if(attributeNames[i] == attribute) {
                index = i;
                isAttributeFound = true;
                break;
            }
        }
        require(isAttributeFound, "Invalid Attribute Name");
        return index;
    }
}

contract BasePoll /*is IPoll */{
    struct Proposal {
        uint voteCount;
        uint voteWeight;
        bytes32 name;
    }

    struct Voter {
        bool voted;
        uint8 vote;   // index of the voted proposal
        address delegate;
        uint weight;
        //uint timeStamp;
    }

    string public pollName;
    string public pollType;
    string public voterBaseLogic;

    Proposal[] public proposals;
    address[] public protocolAddresses;

    mapping(address => Voter) public voters;

    event TriedToVote(address indexed _from, uint indexed _to, uint voteWeight);
    event CastVote(address indexed _from, uint indexed _to, uint voteWeight);
    event RevokedVote(address indexed _from, uint indexed _to, uint voteWeight);

    modifier isValidVoter() {
        require(canVote(msg.sender), "Not a valid voter");
        _;
    }

    constructor(address[] _protocolAddresses, bytes32[] _proposalNames) public {
        //Make sure _proposalNames length < 32
        require(_proposalNames.length <= 32, "Proposals must be less than 32");
        protocolAddresses = _protocolAddresses;
        voterBaseLogic = "WanChain | US & China | Developers"; //initialize here
        pollName = "Admin Election for Autumn 2018"; //initialize here
        pollType = "Token (WAN) weighted poll";
        for (uint8 i = 0; i < _proposalNames.length; i++) {
            proposals.push(Proposal({name: _proposalNames[i], voteCount: 0, voteWeight: 0}));
        }
    }

    function getName() external view returns (string) {
        return pollName;
    }

    function getPollType() external view returns (string) {
        return pollType;
    }

    function getVoterBaseLogic() external view returns (string) {
        return voterBaseLogic;
    }

    function getProtocolAddresses() external view returns (address[]) {
        return protocolAddresses;
    }

    function getProposals() external view returns (bytes32[]) {
        bytes32[] memory proposalNames = new bytes32[](32);
        for(uint8 index = 0; index < proposals.length; index++) {
            proposalNames[index] = (proposals[index].name);
        }
        return proposalNames;
    }

    function canVote(address _to) public view returns (bool) {
        //This is to be filled by user before deploying poll. Can't be modified after poll is deployed. Here is a sample.
        //You can also use attributes to set parameters here
        IERC1261 contract1 = IERC1261(protocolAddresses[0]);
        //IERC1261 contract2 = IERC1261(protocolAddresses[1]);
        //IERC1261 contract3 = IERC1261(protocolAddresses[2]);
        //&& contract2.isCurrentMember(_to) && (contract3.getAttributeByName(_to, 'Country') == 'India')
        return contract1.isCurrentMember(_to);
    }

    function getVoteTally(uint _proposalId) external view returns (uint) {
        return proposals[_proposalId].voteWeight;
    }

    function getVoteTallies() external view returns (uint[]) {
        uint[] memory proposalWeights = new uint[](32);
        for(uint8 index = 0; index < proposals.length; index++) {
            proposalWeights[index] = proposals[index].voteWeight;
        }
        return proposalWeights;
    }

    function getVoterCount(uint _proposalId) external view returns (uint) {
        return proposals[_proposalId].voteCount;
    }

    function getVoterCounts() external view returns (uint[]) {        
        uint[] memory proposalCounts = new uint[](32);
        for(uint8 index = 0; index < proposals.length; index++) {
            proposalCounts[index] = proposals[index].voteCount;
        }
        return proposalCounts;
    }

    function winningProposal() external view returns (uint8) {
        uint8 winningProposalIndex = 0;
        uint winningVoteCount = 0;
        for (uint8 p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposalIndex = p;
            }
        }
        return winningProposalIndex;
    }

    function calculateVoteWeight(address _to) public view returns (uint);
    function vote(uint8 _proposalId) external;
    function revokeVote() external;
}

contract OnePersonOneVote is BasePoll {

    constructor(address[] _protocolAddresses, bytes32[] _proposalNames) public BasePoll(_protocolAddresses, _proposalNames) {
        
    }
    
    function calculateVoteWeight(address _to) public view returns (uint) {
        return 1;
    }

    function vote(uint8 _proposal) external {
        Voter storage sender = voters[msg.sender];
        uint voteWeight = calculateVoteWeight(msg.sender);
        emit TriedToVote(msg.sender, _proposal, voteWeight);
        if(canVote(msg.sender) && !sender.voted) {
            sender.voted = true;
            sender.vote = _proposal;
            sender.weight = voteWeight;
            proposals[_proposal].voteWeight += sender.weight;
            proposals[_proposal].voteCount += 1;
            emit CastVote(msg.sender, _proposal, sender.weight);
        }
    }

    function revokeVote() external isValidVoter {
        Voter storage sender = voters[msg.sender];
        require(sender.voted, "Hasn't yet voted.");
        uint votedProposal = sender.vote;
        uint voteWeight = sender.weight;
        sender.voted = false;        
        proposals[sender.vote].voteWeight -= sender.weight;
        proposals[sender.vote].voteCount -= 1;
        sender.vote = 0;
        sender.weight = 0;
        emit RevokedVote(msg.sender, votedProposal, voteWeight);
    }
}


owner - 0x593efc224e3742b9adf38b0ee333cad078cb2105
member - 0x43ce12056aa1e8372ab4abf0c0cc658d2d41077f
electusprotocol - 0x60ac23d9653c49b7205a1cab4cf4e967d470756c

electusprotocol - ["0x60ac23d9653c49b7205a1cab4cf4e967d470756c"]
proposals - ["0x68656c6c6f0000000000000000000000","0x776f726c640000000000000000000000"]

voting contract - 0xce7ab7093a056598c53b5d87082c7019eb2275db

abi - [
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"name": "_from",
				"type": "address"
			},
			{
				"indexed": true,
				"name": "_to",
				"type": "uint256"
			},
			{
				"indexed": false,
				"name": "voteWeight",
				"type": "uint256"
			}
		],
		"name": "RevokedVote",
		"type": "event"
	},
	{
		"constant": false,
		"inputs": [],
		"name": "revokeVote",
		"outputs": [],
		"payable": false,
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"name": "_from",
				"type": "address"
			},
			{
				"indexed": true,
				"name": "_to",
				"type": "uint256"
			},
			{
				"indexed": false,
				"name": "voteWeight",
				"type": "uint256"
			}
		],
		"name": "TriedToVote",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"name": "_from",
				"type": "address"
			},
			{
				"indexed": true,
				"name": "_to",
				"type": "uint256"
			},
			{
				"indexed": false,
				"name": "voteWeight",
				"type": "uint256"
			}
		],
		"name": "CastVote",
		"type": "event"
	},
	{
		"constant": false,
		"inputs": [
			{
				"name": "_proposal",
				"type": "uint8"
			}
		],
		"name": "vote",
		"outputs": [],
		"payable": false,
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"name": "_protocolAddresses",
				"type": "address[]"
			},
			{
				"name": "_proposalNames",
				"type": "bytes32[]"
			}
		],
		"payable": false,
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"constant": true,
		"inputs": [
			{
				"name": "_to",
				"type": "address"
			}
		],
		"name": "calculateVoteWeight",
		"outputs": [
			{
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [
			{
				"name": "_to",
				"type": "address"
			}
		],
		"name": "canVote",
		"outputs": [
			{
				"name": "",
				"type": "bool"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "getName",
		"outputs": [
			{
				"name": "",
				"type": "string"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "getPollType",
		"outputs": [
			{
				"name": "",
				"type": "string"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "getProposals",
		"outputs": [
			{
				"name": "",
				"type": "bytes32[]"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "getProtocolAddresses",
		"outputs": [
			{
				"name": "",
				"type": "address[]"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "getVoterBaseLogic",
		"outputs": [
			{
				"name": "",
				"type": "string"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [
			{
				"name": "_proposalId",
				"type": "uint256"
			}
		],
		"name": "getVoterCount",
		"outputs": [
			{
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "getVoterCounts",
		"outputs": [
			{
				"name": "",
				"type": "uint256[]"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "getVoteTallies",
		"outputs": [
			{
				"name": "",
				"type": "uint256[]"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [
			{
				"name": "_proposalId",
				"type": "uint256"
			}
		],
		"name": "getVoteTally",
		"outputs": [
			{
				"name": "",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "pollName",
		"outputs": [
			{
				"name": "",
				"type": "string"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "pollType",
		"outputs": [
			{
				"name": "",
				"type": "string"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [
			{
				"name": "",
				"type": "uint256"
			}
		],
		"name": "proposals",
		"outputs": [
			{
				"name": "voteCount",
				"type": "uint256"
			},
			{
				"name": "voteWeight",
				"type": "uint256"
			},
			{
				"name": "name",
				"type": "bytes32"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [
			{
				"name": "",
				"type": "uint256"
			}
		],
		"name": "protocolAddresses",
		"outputs": [
			{
				"name": "",
				"type": "address"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "voterBaseLogic",
		"outputs": [
			{
				"name": "",
				"type": "string"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [
			{
				"name": "",
				"type": "address"
			}
		],
		"name": "voters",
		"outputs": [
			{
				"name": "voted",
				"type": "bool"
			},
			{
				"name": "vote",
				"type": "uint8"
			},
			{
				"name": "delegate",
				"type": "address"
			},
			{
				"name": "weight",
				"type": "uint256"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	},
	{
		"constant": true,
		"inputs": [],
		"name": "winningProposal",
		"outputs": [
			{
				"name": "",
				"type": "uint8"
			}
		],
		"payable": false,
		"stateMutability": "view",
		"type": "function"
	}
]


const contractInstance = await new web3.eth.Contract(abi, 0xce7ab7093a056598c53b5d87082c7019eb2275db);

const name = await contractInstance.methods.getName().call();
const pollType = await contractInstance.methods.getPollType().call();
const protocolAddresses = await contractInstance.methods.getprotocolAddresses().call();

//node_modules/.bin/testrpc-sc --gasLimit 0xfffffffffff --port 8555 & SOLIDITY_COVERAGE=1  && istanbul check-coverage